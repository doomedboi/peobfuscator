#include "AsmWrapperX32.h"

using namespace asmjit;



void  AsmWrapperX86::GeneratePrologue() {
    _assm->push(x86::ebp);
    _assm->mov(x86::ebp, x86::esp);
}

void AsmWrapperX86::GenerateEpiloge() {
    _assm->mov(x86::esp, x86::ebp);
    _assm->pop(x86::ebp);
    _assm->ret();
}

// NOTE: if we call function generated by compiler and cc equals STDCALL,
// callingConvention param = __STDCALL, It will break stack because of function's itself stack correcting
void AsmWrapperX86::GenerateCall(functionAddress faddr, std::vector<ArgType> args,
    CallingConv callingConv) {
    
    //Do we need to make stack align? Hacker can make pattern and marks our obf. funcs

    /*Set args (only stack in x32*/
    for (const auto& arg : args) {
        PushArg(arg);
    }

    /*actual call*/
    if (std::holds_alternative<asmjit::Label>(faddr)) {
        Assembler()->call(std::get<asmjit::Label>(faddr));
        return;
    }
    else if (std::holds_alternative<asmjit::Imm>(faddr)) {
        Assembler()->mov(asmjit::x86::eax, std::get<asmjit::Imm>(faddr));
        Assembler()->call(asmjit::x86::eax);
    }
    else if (std::holds_alternative<asmjit::RegGroup>(faddr)) {
        Assembler()->call(std::get<asmjit::RegGroup>(faddr));
    }

    if (callingConv == IAssembler::CallingConv::__STDCALL) {
        Assembler()->add(asmjit::x86::esp, args.size() * sizeof(DWORD));
    }
    
    
}

void AsmWrapperX86::GenerateJunk(JunkType junkType)
{    
    auto a = GetRandomRegister(rand());
    auto b = GetRandomRegister(rand());

    switch (junkType)
    {    
    case JunkType::REGMOVEMENT:       
        while (a == b)
            b = GetRandomRegister(rand());

        Assembler()->push(a);
        Assembler()->mov(a, b);
        Assembler()->pop(b);
        break;
    case JunkType::STACKABUSE:
        auto countLoops = utils::rand(6, 20);
        for (int i = 0; i < countLoops; ++i) {
            RandomCommand(utils::rand(0, 1));
        }

        if (pushCount > 0)
            Assembler()->add(x86::esp, sizeof(DWORD) * pushCount);

        
        
        Assembler()->mov(x86::bl, x86::ecx);
        Assembler()->inc(x86::ecx);
        break;    
    }
}

/*debug section*/
#define RET666 Assembler()->mov(x86::eax, 0x666);
#define PRINT    printf("Hello!\n");

// think about is returning funcInfo
// TODO: we dont touch any local variables, need to make some one
functionAddress AsmWrapperX86::GenerateFunction(functionBlock funcBlock)
{
    // сейчас у нас нет обработки принимать арги....
    auto addr = Assembler()->newLabel();
    Assembler()->bind(addr);

    bool hasPrEpilog = funcBlock.fi.hasEpilogPrologue;
    if (hasPrEpilog)
        GenerateEpiloge();

    /*local vars*/
    auto localSectionBegin = hasPrEpilog ? asmjit::x86::ebp : asmjit::x86::esp;
    


    /*processing of need to call*/
    /*TODO: random insertion of this*/
    for (auto func : funcBlock.needToCall) {
        GenerateCall(func.addres,
            func.parameters, func.cc);
    }
            
    for (int i = 0; i < utils::rand(4, 10); ++i)
        GenerateJunk(static_cast<JunkType>(utils::rand(0x1, 0x2)));

    if (hasPrEpilog)
        GenerateEpiloge();
    else
        Assembler()->ret();


    return addr;
}

void AsmWrapperX86::AllocStackSpace(stackVariarity reg, std::size_t size)
{
    auto originalAddress = reg;
    Assembler()->sub(reg, size);
}

void AsmWrapperX86::PushArg(ArgType argType)
{
    //TODO: add a method that return a type...
    if (std::holds_alternative<asmjit::Imm>(argType)) {
        // mvsc uses push / pop
        // GCC uses directly manipulating w/ sp
        // TODO: add variantity?
        Assembler()->push(std::get<asmjit::Imm>(argType));
    }
}

void AsmWrapperX86::RandomCommand(size_t command)
{
    auto commandIndex = utils::rand(0, 1);
    // add a switch with enum
    if (commandIndex == 0) {
        Assembler()->push(utils::rand(0x1, 0x100));
        pushCount += 1;
    }
    // pop with no args
    if (commandIndex == 1) {
        if (pushCount > 0) {
            Assembler()->add(x86::esp, 4);
            pushCount -= 1;
        }
    }

}
